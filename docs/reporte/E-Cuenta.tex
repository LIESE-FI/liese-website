\chapter{Implementación del Sistema}
\label{chap:implementacion}

Este capítulo describe la implementación técnica del sistema de telemetría vehicular, incluyendo la estructura del código, configuración de servicios y detalles de desarrollo.

\section{Estructura del Proyecto}

\subsection{Organización de Directorios}

\begin{verbatim}
liese-av-geotel-mqtt-writter/
|-- Makefile                     # Comandos de automatización
|-- docker-compose.yml           # Orquestación de servicios
|-- Dockerfile                   # Imagen del writer
|-- requirements.txt             # Dependencias Python
|-- .env                         # Variables de entorno
|-- .env.example                 # Plantilla de configuración
|-- README.md                    # Documentación principal
|
|-- src/                         # Código fuente
|   |-- main.py                  # Punto de entrada
|   |-- Schemas/                 # Lógica de negocio
|   |   |-- __init__.py
|   |   \-- Writer.py            # Procesador MQTT -> DB
|   |-- Services/                # Servicios de infraestructura
|   |   |-- __init__.py
|   |   \-- DatabaseConnection.py # Conexión y operaciones DB
|   \-- Database/                # Scripts de base de datos
|       \-- Diagrama AV.sql      # Esquema de la BD
|
|-- create_sample_data.py        # Datos de ejemplo
|-- simulate_mqtt.py             # Simulador de telemetría
\-- docs/                        # Documentación técnica
\end{verbatim}

\section{Implementación del Servicio MQTT Writer}

\subsection{Clase Principal: MQTTToDatabaseWriter}

La clase principal implementa la lógica de conexión MQTT y procesamiento de datos:

\begin{verbatim}
class MQTTToDatabaseWriter:
    def __init__(self, db_connection, mqtt_config):
        self.db_connection = db_connection
        self.mqtt_config = mqtt_config
        self.client = mqtt.Client()
        self.setup_mqtt_callbacks()
    
    def setup_mqtt_callbacks(self):
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        self.client.on_disconnect = self.on_disconnect
    
    def on_message(self, client, userdata, msg):
        # Procesar mensaje recibido
        topic = msg.topic
        payload = msg.payload.decode('utf-8')
        self.process_telemetry_data(topic, payload)
\end{verbatim}

\subsection{Procesamiento de Datos de Telemetría}

El método \texttt{process\_telemetry\_data} implementa la lógica principal:

\begin{enumerate}[noitemsep]
    \item \textbf{Parsing del Topic}: Extrae el ID de unidad y tipo de parámetro
    \item \textbf{Validación}: Verifica que la unidad exista en la base de datos
    \item \textbf{Conversión}: Transforma el payload a formato numérico
    \item \textbf{Almacenamiento}: Inserta los datos en la tabla Telemetries
    \item \textbf{Logging}: Registra la operación para monitoreo
\end{enumerate}

\section{Configuración de Base de Datos}

\subsection{Clase DatabaseConnection}

Esta clase maneja todas las operaciones de base de datos:

\begin{verbatim}
class DatabaseConnection:
    def __init__(self, connection_string):
        self.engine = create_engine(connection_string)
        self.Session = sessionmaker(bind=self.engine)
    
    def insert_telemetry(self, unit_id, parameter, value, raw_data):
        session = self.Session()
        try:
            telemetry = Telemetry(
                unit_id=unit_id,
                parameter=parameter,
                value=value,
                timestamp=datetime.now(),
                raw_data=raw_data
            )
            session.add(telemetry)
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            logging.error(f"Error inserting telemetry: {e}")
            return False
        finally:
            session.close()
\end{verbatim}

\subsection{Esquema de Base de Datos}

El archivo \texttt{Diagrama AV.sql} define la estructura completa:

\begin{verbatim}
-- Tabla de unidades vehiculares
CREATE TABLE "Units" (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    model VARCHAR(255),
    plate VARCHAR(20),
    status BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla de telemetría
CREATE TABLE "Telemetries" (
    id BIGSERIAL PRIMARY KEY,
    unit_id INTEGER REFERENCES "Units"(id),
    parameter VARCHAR(100) NOT NULL,
    value DECIMAL(10,4),
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    raw_data BYTEA
);
\end{verbatim}

\section{Containerización con Docker}

\subsection{Dockerfile}

El Dockerfile define la imagen del servicio Python:

\begin{verbatim}
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY src/ ./src/
COPY create_sample_data.py .
COPY simulate_mqtt.py .

CMD ["python", "src/main.py"]
\end{verbatim}

\subsection{Docker Compose}

La configuración orquesta todos los servicios:

\begin{verbatim}
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: geotel_db
      POSTGRES_USER: geotel_user
      POSTGRES_PASSWORD: geotel_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./src/Database:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"

  mqtt-writer:
    build: .
    depends_on:
      - postgres
    environment:
      - POSTGRES_HOST=postgres
      - MQTT_BROKER=host.docker.internal
    volumes:
      - ./src:/app/src
    restart: unless-stopped

  pgadmin:
    image: dpage/pgadmin4:latest
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@geotel.com
      PGADMIN_DEFAULT_PASSWORD: admin123
    ports:
      - "8080:80"
    profiles:
      - admin
\end{verbatim}

\section{Automatización con Makefile}

\subsection{Comandos Principales}

El Makefile proporciona comandos para gestión del proyecto:

\begin{verbatim}
setup: build up
	@echo "Esperando que los servicios estén listos..."
	@sleep 10
	@make sample-data
	@echo "¡Sistema listo!"

build:
	docker-compose build

up:
	docker-compose up -d

sample-data:
	docker-compose exec mqtt-writer python create_sample_data.py

simulate:
	docker-compose exec mqtt-writer python simulate_mqtt.py

test-mqtt:
	mosquitto_pub -h localhost -t "U1_Combustible" -m "75.5"
	mosquitto_pub -h localhost -t "U1_Velocidad" -m "85.2"
\end{verbatim}

\section{Scripts de Soporte}

\subsection{Generador de Datos de Ejemplo}

El script \texttt{create\_sample\_data.py} pobla la base de datos:

\begin{verbatim}
def create_sample_units():
    units_data = [
        {"name": "Unidad 1", "model": "Ford Transit", "plate": "ABC-123"},
        {"name": "Unidad 2", "model": "Mercedes Sprinter", "plate": "DEF-456"},
        {"name": "Unidad 3", "model": "Iveco Daily", "plate": "GHI-789"},
        {"name": "Unidad 4", "model": "Volkswagen Crafter", "plate": "JKL-012"},
        {"name": "Unidad 5", "model": "Renault Master", "plate": "MNO-345"}
    ]
    
    for unit_data in units_data:
        db.insert_unit(unit_data)
\end{verbatim}

\subsection{Simulador MQTT}

El script \texttt{simulate\_mqtt.py} genera datos de prueba:

\begin{verbatim}
def simulate_telemetry_data(unit_id, delay=3):
    parameters = {
        'Combustible': lambda: random.uniform(0, 100),
        'Velocidad': lambda: random.uniform(0, 120),
        'RPM': lambda: random.randint(600, 4000),
        'Temperatura': lambda: random.randint(70, 110),
        'Panic': lambda: random.choice([0, 1])
    }
    
    while True:
        for param, generator in parameters.items():
            topic = f"U{unit_id}_{param}"
            value = generator()
            client.publish(topic, str(value))
            logging.info(f"Published {topic}: {value}")
        
        time.sleep(delay)
\end{verbatim}
