\chapter{Análisis y Diseño del Sistema}
\label{chap:analisis}

Este capítulo presenta el análisis detallado de los requerimientos del sistema de telemetría vehicular y el diseño de la arquitectura que permite la comunicación eficiente entre dispositivos MQTT y la base de datos PostgreSQL.

\section{Análisis de Requerimientos}

\subsection{Requerimientos Funcionales}

El sistema debe cumplir con los siguientes requerimientos funcionales:

\begin{enumerate}[noitemsep]
    \item \textbf{RF-01 Recepción de Mensajes MQTT}: El sistema debe ser capaz de recibir mensajes MQTT de múltiples unidades vehiculares de forma simultánea.
    
    \item \textbf{RF-02 Procesamiento de Datos}: Los mensajes recibidos deben ser procesados, validados y transformados al formato requerido para almacenamiento.
    
    \item \textbf{RF-03 Almacenamiento en Base de Datos}: Los datos procesados deben almacenarse de forma persistente en una base de datos PostgreSQL.
    
    \item \textbf{RF-04 Gestión de Unidades Vehiculares}: El sistema debe mantener un registro de las unidades vehiculares y sus características.
    
    \item \textbf{RF-05 Manejo de Diferentes Tipos de Telemetría}: Soporte para múltiples parámetros vehiculares (combustible, velocidad, RPM, temperatura, GPS, pánico).
    
    \item \textbf{RF-06 Logging y Monitoreo}: Registro detallado de todas las operaciones para facilitar el debugging y monitoreo.
    
    \item \textbf{RF-07 Simulación de Datos}: Capacidad de generar datos de prueba para testing y desarrollo.
\end{enumerate}

\subsection{Requerimientos No Funcionales}

\begin{enumerate}[noitemsep]
    \item \textbf{RNF-01 Rendimiento}: El sistema debe procesar al menos 1000 mensajes MQTT por minuto.
    
    \item \textbf{RNF-02 Disponibilidad}: El sistema debe mantener una disponibilidad del 99.5\% durante las horas operativas.
    
    \item \textbf{RNF-03 Escalabilidad}: La arquitectura debe permitir el escalado horizontal para manejar más unidades vehiculares.
    
    \item \textbf{RNF-04 Mantenibilidad}: El código debe ser modular y bien documentado para facilitar el mantenimiento.
    
    \item \textbf{RNF-05 Portabilidad}: El sistema debe ejecutarse consistentemente en diferentes entornos mediante containerización.
    
    \item \textbf{RNF-06 Seguridad}: Los datos deben transmitirse y almacenarse de forma segura.
    
    \item \textbf{RNF-07 Recuperación}: El sistema debe recuperarse automáticamente de fallos menores.
\end{enumerate}

\section{Arquitectura del Sistema}

\subsection{Arquitectura General}

El sistema implementa una arquitectura basada en microservicios que separa las responsabilidades en componentes independientes:

\begin{itemize}[noitemsep]
    \item \textbf{Capa de Comunicación}: Broker MQTT (Mosquitto) para manejo de mensajería
    \item \textbf{Capa de Procesamiento}: Servicio Python para procesamiento de datos
    \item \textbf{Capa de Almacenamiento}: Base de datos PostgreSQL para persistencia
    \item \textbf{Capa de Administración}: pgAdmin para gestión de base de datos
    \item \textbf{Capa de Orquestación}: Docker Compose para gestión de servicios
\end{itemize}

\subsection{Diagrama de Arquitectura}

\begin{center}
\begin{tabular}{c c c}
\framebox[2.5cm]{Dispositivos} & & \framebox[2.5cm]{MQTT Broker} \\
\framebox[2.5cm]{Vehiculares} & $\rightarrow$ & \framebox[2.5cm]{(Mosquitto)} \\
\framebox[2.5cm]{(IoT Units)} & & \\
\end{tabular}

\vspace{0.3cm}
$\downarrow$
\vspace{0.3cm}

\begin{tabular}{c c c}
& \framebox[2.5cm]{MQTT Writer} & \\
& \framebox[2.5cm]{(Python)} & \\
\end{tabular}

\vspace{0.3cm}
$\downarrow$
\vspace{0.3cm}

\begin{tabular}{c c}
\framebox[2.5cm]{PostgreSQL} & \framebox[2.5cm]{pgAdmin} \\
\framebox[2.5cm]{(Database)} & \framebox[2.5cm]{(Web Interface)} \\
\end{tabular}
\end{center}

\section{Diseño de Base de Datos}

\subsection{Modelo Entidad-Relación}

El modelo de datos está diseñado para almacenar eficientemente la información de telemetría vehicular:

\subsubsection{Entidad: Units}
Almacena información de las unidades vehiculares.

\begin{itemize}[noitemsep]
    \item \textbf{id}: Identificador único (PRIMARY KEY)
    \item \textbf{name}: Nombre descriptivo de la unidad
    \item \textbf{model}: Modelo del vehículo
    \item \textbf{plate}: Placa vehicular
    \item \textbf{status}: Estado activo/inactivo
    \item \textbf{created\_at}: Timestamp de creación
\end{itemize}

\subsubsection{Entidad: Telemetries}
Registra todos los datos de telemetría recibidos.

\begin{itemize}[noitemsep]
    \item \textbf{id}: Identificador único (PRIMARY KEY)
    \item \textbf{unit\_id}: Referencia a Units (FOREIGN KEY)
    \item \textbf{parameter}: Tipo de parámetro medido
    \item \textbf{value}: Valor numérico del parámetro
    \item \textbf{timestamp}: Momento de la medición
    \item \textbf{raw\_data}: Datos originales en formato binario
\end{itemize}

\subsection{Relaciones}
\begin{itemize}[noitemsep]
    \item Units (1) $\leftrightarrow$ (N) Telemetries: Una unidad puede tener múltiples registros de telemetría
\end{itemize}

\section{Diseño de la API MQTT}

\subsection{Estructura de Topics}

El sistema utiliza una convención estructurada para los topics MQTT:

\texttt{U\{ID\}\_\{PARAMETER\}}

Donde:
\begin{itemize}[noitemsep]
    \item \textbf{ID}: Identificador numérico de la unidad vehicular
    \item \textbf{PARAMETER}: Tipo de parámetro (Combustible, Velocidad, RPM, etc.)
\end{itemize}

\subsection{Ejemplos de Topics}
\begin{itemize}[noitemsep]
    \item \texttt{U1\_Combustible}: Nivel de combustible de la unidad 1
    \item \texttt{U2\_Velocidad}: Velocidad actual de la unidad 2
    \item \texttt{U3\_RPM}: RPM del motor de la unidad 3
    \item \texttt{U1\_Temperatura}: Temperatura del motor de la unidad 1
    \item \texttt{U5\_Panic}: Estado de botón de pánico de la unidad 5
\end{itemize}

\section{Flujo de Datos}

\subsection{Proceso de Recepción y Almacenamiento}

\begin{enumerate}[noitemsep]
    \item \textbf{Publicación}: Los dispositivos vehiculares publican mensajes en topics específicos del broker MQTT
    
    \item \textbf{Suscripción}: El servicio Python se suscribe a los patterns de topics relevantes
    
    \item \textbf{Recepción}: Al recibir un mensaje, se extrae el ID de unidad y el tipo de parámetro del topic
    
    \item \textbf{Validación}: Se verifica que la unidad exista en la base de datos
    
    \item \textbf{Procesamiento}: El payload se convierte al tipo de dato apropiado
    
    \item \textbf{Almacenamiento}: Los datos se insertan en la tabla Telemetries con timestamp actual
    
    \item \textbf{Logging}: Se registra la operación para monitoreo y debugging
\end{enumerate}

\section{Patrones de Diseño Implementados}

\subsection{Observer Pattern}
El protocolo MQTT implementa naturalmente el patrón Observer, donde:
\begin{itemize}[noitemsep]
    \item \textbf{Subject}: Broker MQTT
    \item \textbf{Observers}: Servicios suscritos a topics específicos
    \item \textbf{Notification}: Mensajes MQTT recibidos
\end{itemize}

\subsection{Repository Pattern}
La clase DatabaseConnection implementa el patrón Repository para:
\begin{itemize}[noitemsep]
    \item Abstraer el acceso a datos
    \item Centralizar la lógica de base de datos
    \item Facilitar testing con mocks
    \item Mantener separación de responsabilidades
\end{itemize}

\subsection{Factory Pattern}
La configuración de servicios utiliza el patrón Factory para:
\begin{itemize}[noitemsep]
    \item Crear instancias de conexiones de base de datos
    \item Configurar clientes MQTT según el entorno
    \item Gestionar diferentes tipos de logging
\end{itemize}
  %  \caption{Consola de Git Bash}
   % \label{}
%\end{figure}
\vspace{-2em}
En este \emph{hands-on} aprenderás a utilizar Git para Windows. Comenzando por aprender a descargarlo, para después crear un proyecto y utilizar los comandos básicos de Git. Se asume que se tiene instalado el editor de texto \href{https://code.visualstudio.com/download}{ Visual Studio Code} y experiencia básica de comandos de la terminal de Windows.

\section{Descarga de Git para Windows}

Para descargar Git para Windows, nos dirigimos a la siguiente página:
